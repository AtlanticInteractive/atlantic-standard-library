--- @typecheck mode: nocheck

--[[
-[BulletCaster]---------------------------------------
	Library that specializes in solving physical object trajectories;
		Provides support for server-authoritative trajectories.

	SlaveMode notice: Slave casters will terminate with Stop() behavior if the master caster
		does not finsh the caster several seconds after MaxTime period. "Caster.IsStopped" can be used
		to acknowledge this in the Caster:OnSolve() listener.

	Functions:

		BulletCaster.NewCaster(Parameters) --> [Caster]
			Parameters   [table]:
				{
					Position = Vector3,
					Direction = Vector3, -- Unit vector
					Physics = {
						Force = 100,
						Gravity = 10,
						MaxTime = 20,

						-- Optional:
						Bouncy = false, -- (Defaults to false) Whether the projectile can bounce off solid objects
						MaxBounceCount = 5, -- (Defaults to 5)
						Elasticity = 0.5, -- (Defaults to 0.5)
						Friction = 0.1, -- (Defaults to 0.1)
					},

					-- Optional:
					CollisionGroup = "", -- (Defaults to "Default")
					SlaveMode = false, -- (Defaults to false) Slave casters will completely rely on hit events generated by master casters
				}

		BulletCaster.NewCasterJobGroup() --> [CasterJobGroup]

	Members [Caster]:

		-- Everything read-only:

		Caster.CastParams     [table] -- Params that were passed to Caster.NewCaster()

		Caster.IsCrashing     [bool]
		Caster.IsSolved       [bool] -- Set to true when the caster trajectory has been finished in either live or calculation mode
		Caster.IsStopped      [bool] -- Whether Caster:Stop() was called before caster was solved

		-- These values are updated before :OnUpdate() listeners are triggered:
		Caster.Position       [Vector3] -- Will be set to last HitEvent.Position if the caster finishes with a hit
		Caster.Direction      [Vector3] -- Unit vector
		Caster.Velocity       [Vector3]

		-- WARNING: :Solve() and :SolveAsync() will not update Position, Direction and Velocity - rely on "Caster.LastHitEvent" for final hit data instead

		Caster.LastHitEvent   [HitEvent] or nil -- Notice: Slave casters do not receive hit events;
			-- Only set to events that affected caster state (Bounce, Crash, Finish)

	Methods [Caster]:

		----- Hit filtering, processing and replication (Set before starting or solving) -----

		Caster:SetHitFilter(HitFilter) -- Used to tell the caster whether to finish, crash or bounce and
			--	affect game state (e.g. cause damage); Slave casters will not receive hit events
			HitFilter   [function] (HitEvent)

		Caster:SetSlaveReplicator(SlaveReplicator) -- Used to replicate bounce data to slave casters; Set this for master caster;
			-- ONLY SENDS BOUNCE EVENTS - Will not send anything for when the caster is solved - user code handles slave caster termination
			SlaveReplicator   [function] (SlavePackage) -- "SlavePackage" variable must be delivered to :RegisterSlavePackage()
				SlavePackage   [string] -- Lua byte string

		----- Verification and miscellaneous: -----

		Caster:SetHitPosition(Position) -- If not finished earlier, caster will finish at this position; Caster.Position will be equal to this position
			Position   [Vector3]

		Caster:IsPositionInFirstArc(Position) --> [bool] -- Fast check on whether a point is within the arc of a non-bouncy caster;
			-- Useful only for non-bouncy caster server-side verification.
			Position   [Vector3]

		Caster:SlaveSolve(SolveParameters) -- Can be used to trigger :OnSolve() for a slave caster and set Caster members to defined values
			SolveParameters   nil or [table]:
				{
					-- Everything is optional:
					Position = Vector3,
					Direction = Vector3,
					Velocity = Vector3,
				}

		----- "Live" and "calculation" modes: -----

		-- Live mode: (Can't be used together with calculation mode methods)

		Caster:Start(CurrentTime) -- Starts live caster mode
			CurrentTime   [TimeFunction()] or nil -- Optionaly be explicit on caster start time; Is not effective in slave mode

		Caster:Update(CurrentTime) -- Start() must be called before updating; Update() should be called for every game frame (Heartbeat)
			CurrentTime   [TimeFunction()] or nil -- Optionaly be explicit on caster update time flow; Is not effective in slave mode

		Caster:StartAuto() -- Simplified caster start and update until the caster is solved; Replaces :Start() and :Update()

		Caster:RegisterSlavePackage(SlavePackage) -- Register packages from master caster to slave caster;
			-- Start() must be called first

		Caster:Stop() -- Assumes caster finished without a final hit; OnSolve() will be triggered.
			-- WARNING: Do not call inside caster listeners.

		Caster:Destroy() -- Alias for Caster:Stop()

		-- Calculation mode: (Can't be used together with live mode methods)

		Caster:Solve() -- Calculates the entire casters lifespan instantly

		Caster:SolveAsync(CasterJobGroup) -- Solves caster asynchronously under a CasterJobGroup budget
			CasterJobGroup   [CasterJobGroup]

		----- Listeners: -----

		Caster:OnUpdate(UpdateFunction) --> [ScriptConnection] -- Used to drive visual elements following caster trajectory

		Caster:OnBounce(BounceFunction) --> [ScriptConnection] -- Can be used to add animation or sound cues to bounces
			BounceFunction   [function] (ImpactEnergy, HitEvent (nil for slave casters))
			-- EXCEPTION: Slave casters will receive nil as the HitEvent parameter

		Caster:OnSolve(SolveFunction) --> [ScriptConnection] -- Listener called immediately if caster already solved

	Members [HitEvent]:

		HitEvent.Caster          [Caster]

		HitEvent.RaycastResult   [RaycastResult]

		HitEvent.Instance        [BasePart] or [Terrain]
		HitEvent.Material        [Enum.Material]
		HitEvent.Position        [Vector3]
		HitEvent.Normal          [Vector3]

		HitEvent.RayDirection    [Vector3] -- (Unit vector) Direction of Raycast that created this event

	Methods [HitEvent]: -- Available inside SetHitFilter(HitFilter) callback only AND only when SlaveMode is set to false

		HitEvent:Finish() -- Finishes caster trajectory; Not finishing a bouncy projectile can let it bounce or crash
		HitEvent:Crash() -- Requests caster to fall straight down (Bouncy casters only);
			-- If called when caster is already crashing, will act like :Finish()
		HitEvent:Bounce() -- Requests caster to bounce; When bounce limit is reached, will act as calling :Crash()

	Methods [CasterJobGroup]:

		CasterJobGroup:SetBudget(Milliseconds) -- How much time can CasterJobGroup consume per game Heartbeat
		CasterJobGroup:StopAllJobs()

--]]

local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")

local Debug = require(script.Parent.Parent.Debugging.Debug)
local Janitor = require(script.Parent.Parent.Parent.Janitor)
local Signal = require(script.Parent.Parent.Parent.Signal)
local TimeFunctions = require(script.Parent.Parent.Utility.TimeFunctions)

local SETTINGS = {
	LogicalFramerate = 60; -- Unbinds caster results from machine framerate
	SlaveTimeout = 1; -- Seconds after MaxTime timeout until slave caster will stop waiting for master caster slave packages

	CasterJobGroupNoDelaySteps = 50; -- Steps to take until checking passed time
	CasterJobGroupDefaultBudget = 1; -- milliseconds

	RobloxMaxRaycastLength = 5_000;

	MinimalVelocity = function(Velocity: Vector3, Gravity: number): Vector3 --> new_velocity -- (v, g are velocity and gravity respectively)
		-- Protection against "approaching infinite" bounce oscillations that usually result in the caster going through the ground;
		-- A minimal velocity linearly proportional to the gravity parameter has been giving consistent acceptable results.
		local SignOfInverseGravity = math.sign(-Gravity)
		local VelocityY = Velocity.Y*SignOfInverseGravity -- Supports both positive and negative gravity

		if VelocityY >= 0 then
			local MinimalY = math.abs(Gravity)/100 -- Minimal bounce velocity
			if VelocityY < MinimalY then
				return Velocity + Vector3.new(0, MinimalY*SignOfInverseGravity, 0)
			end
		end

		return Velocity
	end;

	VerificationError = 0.01;
}

table.freeze(SETTINGS)

----- Module Table -----

local BulletCaster = {}
local RaycastParamsObject = RaycastParams.new()
RaycastParamsObject.BruteForceAllSlow = false
RaycastParamsObject.FilterType = Enum.RaycastFilterType.Blacklist
RaycastParamsObject.IgnoreWater = true

local ActiveCasterJobGroups = {} -- {caster_job_group = true, ...}

-- Performance variables:

local LogicalFramerate = SETTINGS.LogicalFramerate
local SlaveTimeout = SETTINGS.SlaveTimeout
local CasterJobGroupNoDelaySteps = SETTINGS.CasterJobGroupNoDelaySteps
local CasterJobGroupDefaultBudget = SETTINGS.CasterJobGroupDefaultBudget
local MinimalVelocity = SETTINGS.MinimalVelocity
local VerificationError = SETTINGS.VerificationError
local LogicalPeriod = 1/LogicalFramerate

----- Private Functions -----

local function IsNaN(X)
	return X ~= X
end

local function IsSuspiciousPosition(Position: Vector3)
	local Magnitude = Position.Magnitude
	return Magnitude ~= Magnitude or Magnitude > 10_000_000
end

local function DefaultHitFilter(FilterHitEvent: HitEvent)
	if FilterHitEvent.Instance.CanCollide then
		if FilterHitEvent.Caster._CastParams.Physics.Bouncy then
			FilterHitEvent:Bounce()
		else
			FilterHitEvent:Finish()
		end
	end
end

----- Public -----

local HitEvent = {}
HitEvent.ClassName = "HitEvent"
HitEvent.__index = HitEvent

function HitEvent:Finish()
	self._Finish = true
end

function HitEvent:Crash()
	local Caster = self.Caster
	if Caster._CastParams.Physics.Bouncy then
		if Caster.IsCrashing then
			self:Finish()
		else
			self._Crash = true
		end
	end
end

function HitEvent:Bounce()
	local Caster = self.Caster
	local Physics = Caster._CastParams.Physics
	if Physics.Bouncy then
		if Caster._BounceCount >= Physics.MaxBounceCount - 1 then
			self:Crash()
		else
			self._Bounce = true
		end
	end
end

function HitEvent:__tostring()
	return "HitEvent"
end

type PseudoRaycastResult = {
	Instance: BasePart,
	Material: Enum.Material,
	Normal: Vector3,
	Position: Vector3,
}

function HitEvent._new(Caster: Caster, RaycastResult: RaycastResult | PseudoRaycastResult, Direction: Vector3)
	return setmetatable({
		Caster = Caster;

		RaycastResult = RaycastResult;

		Instance = RaycastResult.Instance;
		Material = RaycastResult.Material;
		Position = RaycastResult.Position;
		Normal = RaycastResult.Normal;

		RayDirection = Direction.Unit;

		_Bounce = false;
		_Crash = false;
		_Finish = false;
	}, HitEvent)
end

-- Caster object:

local Caster = {}
Caster.ClassName = "Caster"
Caster.__index = Caster

-- Private:

local function CasterStep(self) --> (HitEvent, HitTime) or (nil, nil) -- Raycasts for segment (or multi-segment) at self._LogicalTimer
	self._MultiSegmentPending = false

	local CastParams = self._CastParams
	local Physics = CastParams.Physics

	local Gravity = Physics.Gravity

	-- Finding positions to raycast between:

	local T0 = self._SegmentT0
	local T1 = self._LogicalTimer*LogicalPeriod

	local DeltaT = T1 - T0
	local D1 = self._SegmentD1
	local D2 = self._SegmentD0 + Vector3.new(0, self._SegmentV0Y*DeltaT + Gravity/2*DeltaT^2, 0) + self._SegmentV0XZ*DeltaT

	-- Verification hit position:

	local IsVerificationSolve = false

	if self._HitPosition ~= nil then
		local Position = self._HitPosition - D1
		local Line = D2 - D1

		local LineUnit = Line.Unit
		local Projection = LineUnit:Dot(Position)

		if Projection >= 0 and Projection <= Line.Magnitude then
			local LineUnitMulProjection = LineUnit*Projection
			if (LineUnitMulProjection - Position).Magnitude < VerificationError then
				D2 = D1 + LineUnitMulProjection -- Not letting the raycast go past the declared hit position
				IsVerificationSolve = true -- Set caster as solved after this raycast
			end
		end
	end

	-- Raycast query:

	local Filtered = {}
	RaycastParamsObject.FilterDescendantsInstances = Filtered
	RaycastParamsObject.CollisionGroup = CastParams.CollisionGroup

	local CurrentHitEvent

	while true do
		local Direction = D2 - D1
		local RaycastResult = Workspace:Raycast(D1, Direction, RaycastParamsObject)
		if RaycastResult ~= nil then
			CurrentHitEvent = HitEvent._new(self, RaycastResult, Direction)
			self._HitFilter(CurrentHitEvent)

			if CurrentHitEvent._Finish or CurrentHitEvent._Crash or CurrentHitEvent._Bounce then
				break
			else
				table.insert(Filtered, CurrentHitEvent.Instance)
				RaycastParamsObject.FilterDescendantsInstances = Filtered
				CurrentHitEvent = nil
			end
		else
			break
		end
	end

	if IsVerificationSolve then
		self.IsSolved = true
		return nil
	end

	-- Trajectory change:

	if CurrentHitEvent ~= nil then
		self.LastHitEvent = CurrentHitEvent

		if CurrentHitEvent._Finish then
			self.IsSolved = true
			return nil
		elseif CurrentHitEvent._Crash or CurrentHitEvent._Bounce then
			self.IsCrashing = self.IsCrashing or CurrentHitEvent._Crash

			-- Bounce logic:

			self._MultiSegmentPending = true

			local HitPosition = CurrentHitEvent.Position
			local HitNormal = CurrentHitEvent.Normal

			-- Impact time calculation is not scientifically accurate here, but should give acceptable results:
			local PreFraction = math.clamp(self._SegmentT0*LogicalFramerate - (self._LogicalTimer - 1), 0, 1)
			local Fraction = math.clamp(PreFraction + (HitPosition - D1).Magnitude/(D2 - D1).Magnitude*(1 - PreFraction), 0, 1)

			if Fraction ~= Fraction then
				Fraction = 1 -- NaN protection
			end

			local HitTime = T1 - (1 - Fraction)*LogicalPeriod
			local OldVelocity = self._SegmentV0XZ + Vector3.new(0, self._SegmentV0Y + Gravity*(HitTime - T0), 0)

			local OldVelocityDotHitNormal = OldVelocity:Dot(HitNormal)
			local NewVelocity = Physics.Elasticity*math.abs(OldVelocityDotHitNormal)*HitNormal + (1 - Physics.Friction)*(OldVelocity - OldVelocityDotHitNormal*HitNormal)

			if self.IsCrashing then
				local GravitySign = -math.sign(Gravity)
				NewVelocity = Vector3.new(0, math.min(0, NewVelocity.Y*GravitySign)*GravitySign, 0)
			end

			NewVelocity = MinimalVelocity(NewVelocity, Gravity)

			self._SegmentT0 = HitTime
			self._SegmentD0 = HitPosition
			self._SegmentD1 = HitPosition

			self._SegmentV0Y = NewVelocity.Y
			self._SegmentV0XZ = Vector3.new(NewVelocity.X, 0, NewVelocity.Z)

			self._BounceCount += 1

			if not self._IsCalculationMode then
				table.insert(self._BounceVisualPath, {D1, HitPosition, OldVelocity, Fraction})
			end

			self._OnBounceSignal:Fire(
				math.max(0, (OldVelocity.Magnitude^2 - NewVelocity.Magnitude^2)/2), -- Impact kinetic energy delta
				CurrentHitEvent
			)

			return CurrentHitEvent, HitTime
		end
	else
		self._SegmentD1 = D2
	end
end

local function CasterSlaveStep(self, CurrentTime)
	local CastParams = self._CastParams
	local Physics = CastParams.Physics

	local Gravity = Physics.Gravity
	local Time = CurrentTime - self._StartTime - self._StartTimeOffset

	-- Bounce replication handling:

	local BounceQueue = self._BounceQueue -- {{t_hit, hit_position, hit_normal, is_crash}, ...},

	while true do
		local BounceEvent = BounceQueue[1] -- {t_hit, hit_position, hit_normal, is_crash}

		if BounceEvent ~= nil then
			local HitTime = BounceEvent[1]

			if Time > HitTime then
				local HitPosition = BounceEvent[2]
				local HitNormal = BounceEvent[3]
				local IsCrash = BounceEvent[4]

				-- Lag / replication step period compensation every bounce event:

				local StartTimeOffset = self._StartTimeOffset
				StartTimeOffset = math.max(StartTimeOffset, Time - HitTime)
				self._StartTimeOffset = StartTimeOffset
				Time = CurrentTime - self._StartTime - StartTimeOffset

				-- Bounce logic:
				local OldVelocity = self._SegmentV0XZ + Vector3.new(0, self._SegmentV0Y + Gravity*(HitTime - self._SegmentT0), 0)

				local OldVelocityDotHitNormal = OldVelocity:Dot(HitNormal)
				local NewVelocity = Physics.Elasticity*math.abs(OldVelocityDotHitNormal)*HitNormal + (1 - Physics.Friction)*(OldVelocity - OldVelocityDotHitNormal*HitNormal)

				if IsCrash then
					local GravitySign = -math.sign(Gravity)
					NewVelocity = Vector3.new(0, math.min(0, NewVelocity.Y*GravitySign)*GravitySign, 0)
				end

				NewVelocity = MinimalVelocity(NewVelocity, Gravity)

				self._SegmentT0 = HitTime
				self._SegmentD0 = HitPosition
				self._SegmentD1 = HitPosition

				self._SegmentV0Y = NewVelocity.Y
				self._SegmentV0XZ = Vector3.new(NewVelocity.X, 0, NewVelocity.Z)

				self._BounceCount += 1

				self._OnBounceSignal:Fire(
					math.max(0, (OldVelocity.Magnitude^2 - NewVelocity.Magnitude^2)/2), -- Impact kinetic energy delta
					nil
				)

				table.remove(BounceQueue, 1)
			else
				break
			end
		else
			break
		end
	end

	-- Visual arc position:
	local SegmentT0 = self._SegmentT0
	local DeltaTime = Time - SegmentT0

	local SegmentV0XZ = self._SegmentV0XZ
	local SegmentV0Y = self._SegmentV0Y

	local NewPosition = self._SegmentD0 + Vector3.new(0, SegmentV0Y*DeltaTime + Gravity/2*DeltaTime^2, 0) + SegmentV0XZ*DeltaTime

	local NewVelocity = SegmentV0XZ + Vector3.new(0, SegmentV0Y + Gravity*DeltaTime, 0)

	self.Position = NewPosition
	self.Velocity = NewVelocity
	self.Direction = NewVelocity.Magnitude > 0 and NewVelocity.Unit or Vector3.new(0, -1, 0)
end

local function CasterJobGroupRemoveCaster(self, CasterToRemove)
	local Jobs = self._Jobs
	local Index = table.find(Jobs, CasterToRemove)
	if Index ~= nil then
		table.remove(Jobs, Index)

		CasterToRemove.IsSolved = true
		CasterToRemove.IsStopped = true

		-- OnSolved listeners:
		CasterToRemove._OnSolveSignal:Fire()

		if Jobs[1] == nil then
			ActiveCasterJobGroups[self] = nil
		end
	end
end

local function CasterJobGroupAddCaster(self, CasterToAdd)
	CasterToAdd._IsCalculationMode = true
	CasterToAdd._CasterJobGroup = self

	table.insert(self._Jobs, CasterToAdd)

	ActiveCasterJobGroups[self] = true
end

-- Public:
export type HitFilter = (HitEvent: HitEvent) -> ()
export type SlaveReplicator = (SlavePackage: string) -> ()

function Caster:SetHitFilter(HitFilter: HitFilter)
	self._HitFilter = HitFilter
	return self
end

function Caster:SetSlaveReplicator(SlaveReplicator: SlaveReplicator)
	self._SlaveReplicator = SlaveReplicator
	return self
end

function Caster:SetHitPosition(Position: Vector3)
	if IsSuspiciousPosition(Position) then
		return
	end

	self._HitPosition = Position
	return self
end

function Caster:IsPositionInFirstArc(Position: Vector3): boolean --> [bool]
	if IsSuspiciousPosition(Position) then
		return false
	end

	-- Going to guess time from both Y and XZ components for better precision for both 0 gravity
	-- 	and casters that perfectly shoot straight up

	local HitTimes = {} -- {t, ...}

	local Physics = self._CastParams.Physics

	local Gravity = Physics.Gravity
	local MaxTime = self._MaxLogicalTimer*LogicalPeriod -- Quantizing MaxTime

	local FirstArc = self._FirstArc
	local D0 = FirstArc.D0
	local V0Y = FirstArc.V0Y
	local V0XZ = FirstArc.V0XZ

	-- Guessing time from Y component:

	if Gravity ~= 0 then
		local D = V0Y^2 + 2*Gravity*(Position.Y - D0.Y)

		if D == 0 then
			table.insert(HitTimes, -V0Y/Gravity)
		elseif D > 0 then
			local SqrtD = math.sqrt(D)
			table.insert(HitTimes, (-V0Y + SqrtD)/Gravity)
			table.insert(HitTimes, (-V0Y - SqrtD)/Gravity)
		end
	end

	-- Guessing time from XZ component:

	local D0XZ = Vector3.new(D0.X, 0, D0.Z)
	local D1XZ = Vector3.new(Position.X, 0, Position.Z)

	if D0XZ ~= D1XZ then
		local V0XZMagnitude = V0XZ.Magnitude
		if V0XZMagnitude > 0 then
			table.insert(HitTimes, (D1XZ - D0XZ).Magnitude/V0XZMagnitude)
		end
	end

	-- Solving free fall formula for guessed times:

	for _, HitTime in ipairs(HitTimes) do
		if HitTime >= 0 and HitTime <= MaxTime then
			-- Finding raycast positioning for guessed time:

			local LogicalTimer = math.max(math.ceil(HitTime*LogicalFramerate), 1)

			local Time1 = (LogicalTimer - 1)*LogicalPeriod
			local Time2 = LogicalTimer*LogicalPeriod

			local D1 = D0 + Vector3.new(0, V0Y*Time1 + Gravity/2*Time1^2, 0) + V0XZ*Time1
			local D2 = D0 + Vector3.new(0, V0Y*Time2 + Gravity/2*Time2^2, 0) + V0XZ*Time2

			-- Checking whether the position was exactly in the raycast path:

			local DeltaPosition = Position - D1
			local Line = D2 - D1
			local LineUnit = Line.Unit
			local Projection = LineUnit:Dot(DeltaPosition)

			if Projection >= 0 and Projection <= Line.Magnitude then
				if (LineUnit*Projection - DeltaPosition).Magnitude < VerificationError then
					return true
				end
			end
		end
	end

	return false
end

export type SolveParameters = {
	Direction: Vector3?,
	Position: Vector3?,
	Velocity: Vector3?,
}

function Caster:SlaveSolve(PossibleSolveParameters: SolveParameters?)
	if self.IsSolved or self._StartTime == 0 or not self._CastParams.SlaveMode then
		return
	end

	local SolveParameters = PossibleSolveParameters or {}
	self.Position = SolveParameters.Position or self.Position
	self.Direction = SolveParameters.Direction or self.Direction
	self.Velocity = SolveParameters.Velocity or self.Velocity

	self.IsSolved = true
	self._OnSolveSignal:Fire()
end

function Caster:Start(PossibleCurrentTime: number?)
	if self._StartTime ~= 0 or self._IsCalculationMode then
		return -- Already started
	end

	local CurrentTime = PossibleCurrentTime
	if CurrentTime == nil or self._CastParams.SlaveMode then
		CurrentTime = TimeFunctions.TimeFunction()
	end

	Debug.Assert(CurrentTime ~= 0, "[BulletCaster]: Can't pass time equal to 0")
	self._StartTime = CurrentTime
end

function Caster:Update(PossibleCurrentTime: number?)
	if self.IsSolved or self._StartTime == 0 or self._IsCalculationMode then
		return
	end

	local IsSlaveMode = self._CastParams.SlaveMode
	local CurrentTime = PossibleCurrentTime
	if CurrentTime == nil or IsSlaveMode then
		CurrentTime = TimeFunctions.TimeFunction()
	end

	if IsSlaveMode then -- Slave mode update exception
		CasterSlaveStep(self, CurrentTime)

		self._OnUpdateSignal:Fire()

		-- Timeout check:

		local Time = CurrentTime - self._StartTime - self._StartTimeOffset
		local MaxTime = self._MaxLogicalTimer*LogicalPeriod

		if Time > MaxTime + SlaveTimeout then
			self.IsSolved = true
			self.IsStopped = true
		end

		-- OnSolved listeners:

		if self.IsSolved then
			self._OnSolveSignal:Fire()
		end

		return
	end

	local FractionalLogicalTimer = math.min((CurrentTime - self._StartTime)*LogicalFramerate, self._MaxLogicalTimer)
	local DesiredLogicalTimer = math.max(math.ceil(FractionalLogicalTimer), 1)

	-- Logical update:

	while self._LogicalTimer < DesiredLogicalTimer do
		self._LogicalTimer += 1
		self._MultiSegmentPending = true
		if self._BounceVisualPath[1] ~= nil then
			self._BounceVisualPath = {}
		end

		while not self.IsSolved and self._MultiSegmentPending do
			local PastIsCrashing = self.IsCrashing
			local CurrentHitEvent, HitTime = CasterStep(self)

			if CurrentHitEvent ~= nil and self._SlaveReplicator ~= nil then
				local HitPosition = CurrentHitEvent.Position
				local HitNormal = CurrentHitEvent.Normal
				local IsCrash = self.IsCrashing == true and PastIsCrashing == false

				local SlavePackage = string.pack( -- {HitTime, HitPosition, HitNormal, IsCrash}
					"nffffffB",
					HitTime,
					HitPosition.X,
					HitPosition.Y,
					HitPosition.Z,
					HitNormal.X,
					HitNormal.Y,
					HitNormal.Z,
					IsCrash and 1 or 0
				)

				self._SlaveReplicator(SlavePackage)
			end
		end

		if self.IsSolved then
			break
		end
	end

	if self._LogicalTimer == self._MaxLogicalTimer then
		self.IsSolved = true
	end

	-- Caster visual position and velocity approximation:

	local IsBounceVisual = false

	-- Step consisted of a bounce:

	if self._BounceVisualPath[1] ~= nil and self.IsSolved ~= true then
		-- self._BounceVisualPath = {{D0, D1, Velocity, Fraction}, ...}

		local VisualPath = self._BounceVisualPath
		local _, Fraction = math.modf(FractionalLogicalTimer)

		local Fraction0 = 0

		for _, Segment in ipairs(VisualPath) do
			local Fraction1 = Segment[4]
			if Fraction1 > Fraction then
				local X = (Fraction - Fraction0)/(Fraction - Fraction0)
				local Velocity = Segment[3]

				self.Position = Segment[1]:Lerp(Segment[2], X)
				self.Velocity = Velocity
				self.Direction = Velocity.Magnitude > 0 and Velocity.Unit or Vector3.new(0, -1, 0)

				IsBounceVisual = true
				break
			else
				Fraction0 = Fraction1
			end
		end
	end

	-- Regular arc formula:

	if not IsBounceVisual then
		local NoUpdate = false

		local Gravity = self._CastParams.Physics.Gravity
		local DeltaTime = FractionalLogicalTimer*LogicalPeriod - self._SegmentT0

		local NewPosition

		if self.IsSolved then
			local LastHitEvent = self.LastHitEvent
			if LastHitEvent ~= nil then
				NewPosition = LastHitEvent.Position
			else
				NoUpdate = true
			end
		else
			NewPosition = self._SegmentD0 + Vector3.new(0, self._SegmentV0Y*DeltaTime + Gravity/2*DeltaTime^2, 0) + self._SegmentV0XZ*DeltaTime
		end

		if not NoUpdate then
			local Velocity = self._SegmentV0XZ + Vector3.new(0, self._SegmentV0Y + Gravity*DeltaTime, 0)

			self.Position = NewPosition
			self.Velocity = Velocity
			self.Direction = Velocity.Magnitude > 0 and Velocity.Unit or Vector3.new(0, -1, 0)
		end
	end

	-- OnUpdate listeners:

	self._OnUpdateSignal:Fire()

	-- OnSolved listeners:
	if self.IsSolved then
		self._OnSolveSignal:Fire()
	end
end

function Caster:StartAuto()
	self:Start()
	local Connection = RunService.Heartbeat:Connect(function()
		self:Update()
	end)

	self:OnSolve(function()
		Connection:Disconnect()
	end)

	self:Update() -- First update
end

function Caster:RegisterSlavePackage(SlavePackage: string)
	local HitTime, HitX, HitY, HitZ, NormalX, NormalY, NormalZ, IsCrash = string.unpack( -- {HitTime, HitPosition, HitNormal, IsCrash}
		"nffffffB",
		SlavePackage
	)

	table.insert(self._BounceQueue, {HitTime, Vector3.new(HitX, HitY, HitZ), Vector3.new(NormalX, NormalY, NormalZ), IsCrash == 1})
end

function Caster:Stop()
	if self.IsSolved or (self._StartTime == 0 and not self._IsCalculationMode) then
		return
	end

	if self._CasterGroupJob ~= nil then
		return CasterJobGroupRemoveCaster(self._CasterGroupJob, self)
	end

	self.IsSolved = true
	self.IsStopped = true

	-- OnSolved listeners:

	self._OnSolveSignal:Fire()
end

function Caster:Destroy()
	self:Stop()
	self._Janitor:Destroy()
	setmetatable(self, nil)
end

function Caster:Solve() -- Calculates the entire casters lifespan instantly
	if self.IsSolved or self._StartTime ~= 0 then
		return
	end

	self._IsCalculationMode = true
	local MaxLogicalTimer = self._MaxLogicalTimer
	while self._LogicalTimer < MaxLogicalTimer do
		self._LogicalTimer += 1
		self._MultiSegmentPending = true

		while not self.IsSolved and self._MultiSegmentPending do
			CasterStep(self)
		end

		if self.IsSolved then
			break
		end
	end

	self.IsSolved = true
	self._OnSolveSignal:Fire()
end

function Caster:SolveAsync(CasterJobGroup: CasterJobGroup)
	if self.IsSolved or self._StartTime ~= 0 or self._IsCalculationMode then
		return
	end

	CasterJobGroupAddCaster(CasterJobGroup, self)
end

function Caster:OnUpdate(UpdateFunction: () -> ()) --> [ScriptConnection]
	return self._Janitor:Add(self._OnUpdateSignal:Connect(UpdateFunction), "Disconnect")
end

export type BounceFunction = (ImpactKineticEnergyDelta: number, HitEvent: HitEvent?) -> ()
function Caster:OnBounce(BounceFunction: BounceFunction) --> [ScriptConnection]
	return self._Janitor:Add(self._OnBounceSignal:Connect(BounceFunction), "Disconnect")
end

function Caster:OnSolve(SolveFunction: () -> ()) --> [ScriptConnection]
	if self.IsSolved then
		SolveFunction()
	end

	return self._Janitor:Add(self._OnSolveSignal:Connect(SolveFunction), "Disconnect")
end

function Caster:__tostring()
	return "Caster"
end

-- CasterJobGroup object:

local CasterJobGroup = {}
CasterJobGroup.ClassName = "CasterJobGroup"
CasterJobGroup.__index = CasterJobGroup

local function CasterJobGroupDoWork(self)
	local StopTime = TimeFunctions.TimeFunction() + self._Budget
	local Jobs = self._Jobs

	local Success, Error = pcall(function() -- Protecting game from a performance hit in case of a broken caster
		while TimeFunctions.TimeFunction() < StopTime do
			local WorkCaster = Jobs[1]

			if WorkCaster == nil then
				ActiveCasterJobGroups[self] = nil
				break
			end

			local MaxLogicalTimer = WorkCaster._MaxLogicalTimer
			local Steps = 0

			while WorkCaster._LogicalTimer < MaxLogicalTimer and Steps < CasterJobGroupNoDelaySteps do
				Steps += 1
				WorkCaster._LogicalTimer += 1
				WorkCaster._MultiSegmentPadding = true

				while not WorkCaster.IsSolved and WorkCaster._MultiSegmentPadding do
					CasterStep(WorkCaster)
				end

				if WorkCaster.IsSolved then
					break
				end
			end

			if WorkCaster._LogicalTimer == WorkCaster._MaxLogicalTimer then
				WorkCaster.IsSolved = true
			end

			-- OnSolved listeners:

			if WorkCaster.IsSolved then
				table.remove(Jobs, 1)
				if Jobs[1] == nil then
					ActiveCasterJobGroups[self] = nil
				end

				WorkCaster._OnSolveSignal:Fire()
			end
		end
	end)

	if not Success then
		Debug.Warn("[BulletCaster]: CasterJobGroup experienced an error:\n" .. tostring(Error))
		self:StopAllJobs()
	end
end

-- Public:
function CasterJobGroup:SetBudget(Milliseconds: number)
	self._Budget = Milliseconds/1000
	return self
end

function CasterJobGroup:StopAllJobs()
	for _, JobCaster in ipairs(self._Jobs) do
		JobCaster.IsSolved = true
		JobCaster.IsStopped = true

		-- OnSolved listeners:=
		JobCaster._OnSolveSignal:Fire()
	end

	self._Jobs = {}
	ActiveCasterJobGroups[self] = nil
end

function CasterJobGroup:__tostring()
	return "CasterJobGroup"
end

-- Module functions:

export type CastParams = {
	Direction: Vector3,
	Position: Vector3,
	Physics: {
		Force: number,
		Gravity: number,
		MaxTime: number,

		Bouncy: boolean?,
		MaxBounceCount: number?,
		Elasticity: number?,
		Friction: number?,
	},

	CollisionGroup: string?,
	SlaveMode: boolean?,
}

function BulletCaster.NewCaster(CastParams: CastParams) --> [Caster]
	local OriginalCastParams = CastParams

	-- Deep copying cast_params:

	local Physics = CastParams.Physics

	CastParams = {
		Position = CastParams.Position;
		Direction = CastParams.Direction;
		Physics = {
			Force = Physics.Force;
			Gravity = -Physics.Gravity;
			MaxTime = Physics.MaxTime;

			-- Optional:
			Bouncy = not not Physics.Bouncy;
			MaxBounceCount = Physics.MaxBounceCount or 5;
			Elasticity = Physics.Elasticity or 0.5;
			Friction = Physics.Friction or 0.1;
		};

		-- Optional:
		CollisionGroup = CastParams.CollisionGroup or "Default";
		SlaveMode = not not CastParams.SlaveMode;
	}

	Physics = CastParams.Physics -- Updating reference to deep copy

	-- A bit of type checking:

	local Position = CastParams.Position
	Debug.Assert(type(Position) == "vector", "[BulletCaster]: Invalid Position argument; got %q", Position)
	Debug.Assert(IsNaN(Position.Magnitude) == false, "[BulletCaster]: Corrupted Position argument (NaN)")

	local Direction = CastParams.Direction
	Debug.Assert(type(Direction) == "vector", "[BulletCaster]: Invalid Direction argument; got %q", Direction)
	Debug.Assert(IsNaN(Direction.Magnitude) == false and Direction.Magnitude > 0, "[BulletCaster]: Direction argument does not contain valid direction")

	Debug.Assert(Physics.Force > 0 or Physics.Gravity ~= 0, "[BulletCaster]: Passed caster parameters apply no forces (0 force and 0 gravity); got %q for Force and %q for Gravity", Physics.Force, Physics.Gravity)

	CastParams.Direction = Direction.Unit
	local Velocity0 = CastParams.Physics.Force*CastParams.Direction

	local self = setmetatable({
		CastParams = OriginalCastParams;

		IsCrashing = false;
		IsSolved = false;
		IsStopped = false;

		Position = CastParams.Position;
		Direction = CastParams.Direction;
		Velocity = Velocity0;

		LastHitEvent = nil;

		_CastParams = CastParams; -- Deep copied cast params

		_StartTime = 0;
		_IsCalculationMode = false;
		_CasterJobGroup = nil;

		_LogicalTimer = 0;
		_MaxLogicalTimer = math.ceil(Physics.MaxTime*LogicalFramerate);
		_MultiSegmentPending = false;

		_SegmentT0 = 0;
		_SegmentD0 = CastParams.Position;
		_SegmentD1 = CastParams.Position;
		_SegmentV0Y = Velocity0.Y;
		_SegmentV0XZ = Vector3.new(Velocity0.X, 0, Velocity0.Z);

		_BounceCount = 0;
		_BounceVisualPath = {};

		_OnUpdateSignal = nil;
		_OnBounceSignal = nil;
		_OnSolveSignal = nil;

		_HitFilter = DefaultHitFilter;
		_SlaveReplicator = nil;

		_BounceQueue = {};
		_StartTimeOffset = 0;

		_FirstArc = {
			D0 = CastParams.Position;
			V0Y = Velocity0.Y;
			V0XZ = Vector3.new(Velocity0.X, 0, Velocity0.Z);
		};

		_HitPosition = nil;
		_Janitor = Janitor.new();
	}, Caster)

	self._OnBounceSignal = Signal.new(self._Janitor)
	self._OnUpdateSignal = Signal.new(self._Janitor)
	self._OnSolveSignal = Signal.new(self._Janitor)
	return self
end

function BulletCaster.NewCasterJobGroup() --> [CasterJobGroup]
	return setmetatable({
		_Budget = CasterJobGroupDefaultBudget/1000;
		_Jobs = {}; -- {caster, ...}
	}, CasterJobGroup)
end

export type Caster = typeof(BulletCaster.NewCaster({
	Direction = Vector3.new();
	Position = Vector3.new();
	Physics = {
		Force = 1;
		Gravity = 1;
		MaxTime = 1;
	};
}))

export type HitEvent = typeof(HitEvent._new(BulletCaster.NewCaster({
	Direction = Vector3.new();
	Position = Vector3.new();
	Physics = {
		Force = 1;
		Gravity = 1;
		MaxTime = 1;
	};
}), {
	Instance = Instance.new("Part");
	Position = Vector3.new();
	Normal = Vector3.new();
	Material = Enum.Material.Plastic;
}, Vector3.new()))

export type CasterJobGroup = typeof(BulletCaster.NewCasterJobGroup())

----- Connections -----

RunService.Heartbeat:Connect(function()
	for ActiveCasterJobGroup in next, ActiveCasterJobGroups do
		CasterJobGroupDoWork(ActiveCasterJobGroup)
	end
end)

table.freeze(Caster)
table.freeze(HitEvent)
table.freeze(CasterJobGroup)
table.freeze(BulletCaster)
return BulletCaster
